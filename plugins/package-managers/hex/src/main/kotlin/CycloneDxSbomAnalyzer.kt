/*
 * Copyright (C) 2025 The ORT Project Authors (see <https://github.com/oss-review-toolkit/ort/blob/main/NOTICE>)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package org.ossreviewtoolkit.plugins.packagemanagers.hex

import java.io.File

import org.cyclonedx.parsers.JsonParser

import org.ossreviewtoolkit.analyzer.PackageManager
import org.ossreviewtoolkit.analyzer.PackageManagerFactory
import org.ossreviewtoolkit.analyzer.PackageManagerResult
import org.ossreviewtoolkit.downloader.VersionControlSystem
import org.ossreviewtoolkit.model.Identifier
import org.ossreviewtoolkit.model.Issue
import org.ossreviewtoolkit.model.Project
import org.ossreviewtoolkit.model.ProjectAnalyzerResult
import org.ossreviewtoolkit.model.Severity
import org.ossreviewtoolkit.model.VcsInfo
import org.ossreviewtoolkit.model.VcsType
import org.ossreviewtoolkit.model.config.AnalyzerConfiguration
import org.ossreviewtoolkit.model.config.Excludes
import org.ossreviewtoolkit.model.utils.DependencyGraphBuilder
import org.ossreviewtoolkit.plugins.api.OrtPlugin
import org.ossreviewtoolkit.plugins.api.PluginDescriptor

internal const val PACKAGE_TYPE = "Hex"
private const val PROJECT_TYPE = "CycloneDX"

/**
 * The [CycloneDxSbomAnalyzer] is a package manager plugin that ingests CycloneDX 1.6 JSON SBOMs
 * generated by Erlang/Elixir SBOM generators (mix_sbom, rebar3_sbom, or standalone tools) and
 * converts them into ORT's internal data structures.
 *
 * This enables ORT to understand Erlang/Elixir dependency graphs without implementing a native
 * lockfile resolver, using CycloneDX as the stable interchange format.
 */
@OrtPlugin(
    displayName = "CycloneDX SBOM Analyzer",
    description = "Analyzes Erlang/Elixir projects via CycloneDX JSON SBOMs.",
    factory = PackageManagerFactory::class
)
class CycloneDxSbomAnalyzer(
    override val descriptor: PluginDescriptor = CycloneDxSbomAnalyzerFactory.descriptor
) : PackageManager(PROJECT_TYPE) {

    override val globsForDefinitionFiles = listOf("bom.cdx.json", "sbom.cdx.json", "*.cyclonedx.json")

    private val dependencyHandler = CycloneDxDependencyHandler()
    private val graphBuilder = DependencyGraphBuilder(dependencyHandler)

    override fun resolveDependencies(
        analysisRoot: File,
        definitionFile: File,
        excludes: Excludes,
        analyzerConfig: AnalyzerConfiguration,
        labels: Map<String, String>
    ): List<ProjectAnalyzerResult> {
        val issues = mutableListOf<Issue>()

        // Parse the CycloneDX JSON file
        val bom = try {
            JsonParser().parse(definitionFile)
        } catch (e: Exception) {
            issues += Issue(
                source = projectType,
                message = "Failed to parse CycloneDX SBOM: ${e.message}",
                severity = Severity.ERROR
            )
            return listOf(
                ProjectAnalyzerResult(
                    project = createFallbackProject(definitionFile),
                    packages = emptySet(),
                    issues = issues
                )
            )
        }

        // Build a map of bom-ref -> dependsOn list from the dependencies section
        val dependsOnMap: Map<String, List<String>> = bom.dependencies?.associate { dep ->
            dep.ref to (dep.dependencies?.map { it.ref } ?: emptyList())
        } ?: emptyMap()

        // Convert CycloneDX components to our internal dependency model
        val allDependencies = bom.components?.map { component ->
            val bomRef = component.bomRef ?: component.purl ?: "${component.name}@${component.version}"
            CycloneDxDependency(
                component = component,
                bomRef = bomRef,
                dependsOn = dependsOnMap[bomRef] ?: emptyList<String>()
            )
        } ?: emptyList()

        // Set up the dependency handler with all dependencies
        dependencyHandler.setDependencies(allDependencies)

        // Create the project from the metadata component
        val project = createProject(definitionFile, bom, issues)

        // Find direct dependencies (dependencies of the root component)
        val rootBomRef = bom.metadata?.component?.bomRef
        val directDependencyRefs = dependsOnMap[rootBomRef] ?: emptyList<String>()
        val directDependencies = allDependencies.filter { it.bomRef in directDependencyRefs }

        // Add dependencies to the graph builder
        if (directDependencies.isNotEmpty()) {
            graphBuilder.addDependencies(project.id, SCOPE_DEPENDENCIES, directDependencies)
        } else if (allDependencies.isNotEmpty()) {
            // If we can't determine direct dependencies, treat all as direct
            issues += Issue(
                source = projectType,
                message = "Could not determine direct dependencies from SBOM dependency graph. " +
                    "Treating all components as direct dependencies.",
                severity = Severity.WARNING
            )
            graphBuilder.addDependencies(project.id, SCOPE_DEPENDENCIES, allDependencies)
        }

        return listOf(
            ProjectAnalyzerResult(
                project = project.copy(scopeNames = graphBuilder.scopesFor(project.id)),
                packages = emptySet(),
                issues = issues
            )
        )
    }

    override fun createPackageManagerResult(projectResults: Map<File, List<ProjectAnalyzerResult>>) =
        PackageManagerResult(projectResults, graphBuilder.build(), graphBuilder.packages())

    /**
     * Create a Project from the CycloneDX metadata component.
     */
    private fun createProject(
        definitionFile: File,
        bom: org.cyclonedx.model.Bom,
        issues: MutableList<Issue>
    ): Project {
        val metadataComponent = bom.metadata?.component

        val projectId = if (metadataComponent != null) {
            Identifier(
                type = projectType,
                namespace = metadataComponent.group.orEmpty(),
                name = metadataComponent.name ?: definitionFile.parentFile.name,
                version = metadataComponent.version.orEmpty()
            )
        } else {
            issues += Issue(
                source = projectType,
                message = "CycloneDX SBOM does not contain metadata.component. " +
                    "Using fallback project identification.",
                severity = Severity.WARNING
            )
            Identifier(
                type = projectType,
                namespace = "",
                name = definitionFile.parentFile.name,
                version = ""
            )
        }

        val declaredLicenses = metadataComponent?.licenses?.licenses?.mapNotNull { licenseChoice ->
            licenseChoice.id ?: licenseChoice.name
        }?.toSet() ?: emptySet()

        val homepageUrl = metadataComponent?.externalReferences?.find {
            it.type == org.cyclonedx.model.ExternalReference.Type.WEBSITE
        }?.url.orEmpty()

        val vcsUrl = metadataComponent?.externalReferences?.find {
            it.type == org.cyclonedx.model.ExternalReference.Type.VCS
        }?.url.orEmpty()

        val vcs = if (vcsUrl.isNotEmpty()) {
            VcsInfo(type = VcsType.GIT, url = vcsUrl, revision = "", path = "")
        } else {
            VcsInfo.EMPTY
        }

        return Project(
            id = projectId,
            definitionFilePath = VersionControlSystem.getPathInfo(definitionFile).path,
            authors = metadataComponent?.author?.let { setOf(it) } ?: emptySet(),
            declaredLicenses = declaredLicenses,
            vcs = vcs,
            vcsProcessed = processProjectVcs(definitionFile.parentFile, vcs),
            homepageUrl = homepageUrl,
            scopeNames = emptySet()
        )
    }

    /**
     * Create a fallback project when SBOM parsing fails.
     */
    private fun createFallbackProject(definitionFile: File): Project =
        Project(
            id = Identifier(
                type = projectType,
                namespace = "",
                name = definitionFile.parentFile.name,
                version = ""
            ),
            definitionFilePath = VersionControlSystem.getPathInfo(definitionFile).path,
            authors = emptySet(),
            declaredLicenses = emptySet(),
            vcs = VcsInfo.EMPTY,
            vcsProcessed = processProjectVcs(definitionFile.parentFile),
            homepageUrl = "",
            scopeNames = emptySet()
        )

    companion object {
        private const val SCOPE_DEPENDENCIES = "dependencies"
    }
}

